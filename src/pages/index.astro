---

---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>Astro</title>
  </head>
  <body>
    <div class="h-screen w-full">
      <canvas
        class="h-screen w-full z-10 relative"
        id="matter-container"
        height="100%"
        width="100%"></canvas>
      <div
        class="absolute inset-0 flex flex-col z-0 justify-center items-center"
      >
        <p>Your Textbox Content</p>
        <input
          type="text"
          class="text-center"
          placeholder="Enter your text here"
        />
      </div>
    </div>
    <!-- <h1>Astro</h1> -->
    <script>
      import Matter from "matter-js";
      const {
        Engine,
        Render,
        World,
        Bodies,
        Body,
        Events,
        Mouse,
        MouseConstraint,
      } = Matter;

      const engine = Engine.create({
        gravity: { x: 0, y: 0, scale: 0.0 },
      });

      const canvas = document.getElementById("matter-container");
      const render = Render.create({
        canvas: canvas,
        engine: engine,
        options: {
          width: canvas!.offsetWidth,
          height: canvas!.offsetHeight,
          hasBounds: true,
          wireframes: false,
          background: "transparent",
        },
      });
      const boxes = [];
      for (let i = 0; i < 500; i++) {
        boxes.push(
          Bodies.rectangle(
            Math.random() * canvas!.offsetWidth,
            Math.random() * canvas!.offsetWidth,
            20,
            20,
            {
              render: {
                fillStyle: "red",
              },
            }
          )
        );
      }
      //   const box = Bodies.rectangle(200, 200, 80, 80);
      // Create edges as static bodies

      const tbox = Bodies.rectangle(
        canvas!.offsetHeight / 2,
        canvas!.offsetWidth / 2,
        canvas!.offsetWidth * 0.6,
        canvas!.offsetHeight * 0.6,
        {
          render: {
            opacity: 0,
          },
          isStatic: true,
        }
      );
      World.add(engine.world, tbox);

      const setupWalls = () => {
        const containerWidth = canvas!.offsetWidth;
        const containerHeight = canvas!.offsetHeight;

        // Update wall positions based on container size
        const ground = Bodies.rectangle(
          containerWidth / 2,
          containerHeight,
          containerWidth,
          1,
          {
            isStatic: true,
            render: { opacity: 0 },
          }
        );
        const ceiling = Bodies.rectangle(
          containerWidth / 2,
          0,
          containerWidth,
          1,
          {
            isStatic: true,
            render: { opacity: 0 },
          }
        );
        const leftWall = Bodies.rectangle(
          0,
          containerHeight / 2,
          1,
          containerHeight,
          {
            isStatic: true,
            render: { opacity: 0 },
          }
        );
        const rightWall = Bodies.rectangle(
          containerWidth,
          containerHeight / 2,
          1,
          containerHeight,
          {
            isStatic: true,
            render: { opacity: 0 },
          }
        );

        // Add all bodies to the world
        World.add(engine.world, [ground, ceiling, leftWall, rightWall]);
      };

      // Call setupWalls initially and whenever window is resized
      setupWalls();
      window.addEventListener("resize", setupWalls);
      World.add(engine.world, boxes);
      // Create a mouse
      const mouse = Mouse.create(render.canvas);
      const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
          render: { visible: false },
        },
      });

      World.add(engine.world, mouseConstraint);

      // Listen for mouse movements
      Events.on(engine, "beforeUpdate", () => {
        const mouseX = mouse.position.x;
        const mouseY = mouse.position.y;

        boxes.forEach((box) => {
          const distanceX = mouseX - box.position.x;
          const distanceY = mouseY - box.position.y;

          const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);

          // Apply repulsion force when the mouse is near the box
          if (distance < 100) {
            const repulsionMagnitude = 0.0001;
            const repulsionX = -distanceX * repulsionMagnitude;
            const repulsionY = -distanceY * repulsionMagnitude;

            Matter.Body.applyForce(box, box.position, {
              x: repulsionX,
              y: repulsionY,
            });
          }
        });
      });
      Engine.run(engine);
      Render.run(render);
    </script>
  </body>
</html>
